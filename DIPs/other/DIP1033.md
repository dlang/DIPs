# Implicit Conversion of Expressions to Delegates

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1033                                                            |
| Review Count:   | 2                                                               |
| Author:         | Walter Bright walter@digitalmars.com                            |
| Implementation: |                                                                 |
| Status:         | Postponed                                                       |

## Abstract

Allow implicit conversion of expressions to delegates. This happens already for
arguments to lazy parameters. This proposal extends it more generally and
lays the foundation for removing `lazy` as a special case delegate.


## Contents
* [Rationale](#rationale)
* [Prior Work](#prior-work)
* [Description](#description)
* [Breaking Changes and Deprecations](#breaking-changes-and-deprecations)
* [Reference](#reference)
* [Copyright & License](#copyright--license)
* [Reviews](#reviews)

## Rationale

Currently, arguments to `lazy` parameters are automatically converted to delegates. The troubles with `lazy` are:

1. it stands out as an oddity
2. being an oddity means it is hard to reason about, especially with the
proliferation of parameter attributes
3. it is underdocumented
4. special case code for it is sprinkled throughout the compiler
5. it is rarely used, so likely has many undetected problems
6. that it works like a delegate has largely gone unrecognized

`lazy` has found a home, however, in functions like this one in `std.path`:
```D
pure @safe string absolutePath(string path, lazy string base = getcwd());
```
where it is undesirable to compute the `base` argument unless it is actually needed.
With this change, it could be rewritten as:

```D
pure @safe string absolutePath(string path, string delegate() base = getcwd());
```
and called the same way.

There's more than supplanting `lazy`. It makes delegates in general easier to write,
and experience suggests that the easier they are to write, the more uses people will
find for them:

```D
int delegate() dg = () { return 3; };
```
or:
```D
int delegate() dg = () => 3;
```
become simply:
```D
int delegate() dg = 3;
```

## Prior Work

None known.

## Description

Allow the implicit conversion of an `Expression` of type `T` to a delegate lambda function that
returns a type `T`. The body of the delegate lambda will be the `Expression` which
will be returned from the lambda.

I.e.:

Given expression `E` of type `T`, it is converted to:

```
T delegate() { return E; }
```

Attribute inference is performed on the function as it is for all lambda functions.

The [match level](http://dlang.org/spec/function.html#function-overloading)
will be: "2. match with implicit conversions".
If the generated delegate lambda is not implicitly convertible to the delegate type
in the funciton declaration, there is no match.

This is a generalization of the current method of converting variadic arguments
to delegates. See [Lazy Variadic Functions](https://dlang.org/spec/function.html#lazy_variadic_functions).

### Grammar Changes

None.

### Function Overloading

```
void biff(int);            // A
void biff(int delegate()); // B

void test(int i)
{
    biff(i);
}
```

`i` is of type `int`, which is an exact match for `A`. A match with `B` would be
via a conversion to a delegate lambda, so `A` is better and is selected.

```
void biff(long);            // A
void biff(long delegate()); // B

void test(int i)
{
    biff(i);
}
```
Both A and B are matched equally at the "conversion" level. Then, partial ordering is
applied. A variable of type `long` can be converted to `long delegate()` lambda, but a
`long delegate()` cannot be converted to `long`. Therefore, `A` is the better match.
This makes sense as the intuitive result.


### `null`

```
void biff(T delegate());

void test()
{
    biff(null);
}
```
`null` implicitly converts directly to any delegate, but is not of type `T`, so it will
not be turned into a lambda. Again, this is what is expected and is consistent
with existing code.


### Function Pointers

Implicit conversion of expressions to function lambdas is not done. There doesn't seem
much point to it, as there will be no arguments to the function lambda, meaning the expression
can only consist of globals.


### Deprecation of `lazy`

Although this DIP renders `lazy` redundant and unnecessary, it does not propose actually
removing `lazy`. That will be deferred for a future DIP.


## Breaking Changes and Deprecations

The only potential difficulty is if delegates are overloaded with other types. But the combination
of matching rules by conversion level and partial ordering appear to resolve this in the direction
of not breaking existing code.

## Reference

None.

## Copyright & License
Copyright (c) 2019-2020 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

## Reviews

### Community Review Round 1
[Reviewed Version](https://github.com/dlang/DIPs/blob/7b61411cb6cf8db05d9b8e1df5d2d9bae53a5f1e/DIPs/DIP1033.md)

[Discussion](https://forum.dlang.org/post/ecxdylguqkhtmdomlzhq@forum.dlang.org)

[Feedback](https://forum.dlang.org/post/nxahrsukobybkezibcsm@forum.dlang.org)

Regarding the section on "Function Pointers", which says "the expression can only consist of globals",
one reviewer brought up the following case in which there are no globals:

```D
int function() = 3;
```

The DIP author replied that it seems pointless to support function pointers only with constants and
that he could think of no compelling use case.

Another reviewer noted that lazy variadic parameters already work as described in the DIP, and lazy "is not expressive enough to cover that case". The DIP author replied that he had overlooked that.

### Final Review
[Reviewed Version](https://github.com/dlang/DIPs/blob/8e56fc593ece5c74f18b8eb68c3f9dcedf2396a7/DIPs/DIP1033.md)

[Discussion](https://forum.dlang.org/post/ysdmdeemnrfwqemkjrlr@forum.dlang.org)

[Feedback](https://forum.dlang.org/post/tvwikrkcqqyeyprfdokg@forum.dlang.org)

The following points were raised in the Feedback Thread:

* A specific example showing that, given a `pure`, `@safe` functions with a `@trusted` delegate parameter, the delegate is both impure and unsafe, leading to a compiler error without auto inference. If auto inference of parameter types is intended, the DIP should detail it. The DIP author replied that a compiler error seems the be proper result.
* The DIP fails to discuss the readability of `lazy`, citing the C# requirement of modifying the caller when, e.g., calling functions with `ref` parameters. The DIP author replied that the C# approach makes refactoring harder, but he did not indicate if he would add such to the DIP.
* There are already multiple ways to declare the same delegate, and this proposal introduces new syntax that would be easily misunderstood and simply replaces one approach with another. The DIP author replied that the goal is to dispense with unnecessary syntax, and that this DIP introduces no new syntax.
* One reviewer quoted the two sentences on function lambdas ("Implicit conversion of expressions to function lambdas is not done. here doesn't seem much point to it, as there will be no arguments to the function lambda, meaning the expression can only consist of globals.") and suggested the DIP should show how this case is not desirable when explicit conversion to delegate is.
* Attributes for functions taking delegates as parameters should be fixed before this feature is implemented.
* The DIP should be amended such that the feature only applies to `scope` delegates, which should only be allocated on the stack, so that non-scope delegates which allocate on the heap can be more visible.

## Addendum
Subsequent to the Final Review, the DIP author requested that the review process be postponed until further notice.