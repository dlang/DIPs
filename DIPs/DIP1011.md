# Free delegate functions

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1011                                                            |
| RC#             | 1 [Most Recent]                                                 |
| Author:         | Jonathan Marler - johnnymarler@gmail.com                        |
| Implementation: | None                                                            |
| Status:         | Formal Review                                                   |

[Most Recent]: https://github.com/dlang/DIPs/blob/69b949be79cba566381ad5de146d0ecc9f21dd5a/DIPs/DIP1011.md

# TODO:

* Need to look into mangling rules for free delegate functions that aren't class/struct references

## Abstract

The goal of this proposal is to unify the function ABI with the delegate ABI enable interaction between themthat is type-safe without introducing overhead. To accomplish this, it is proposed that

* free functions with a reference type as their first parameter use the delegate ABI with the first parameter being passed as the context pointer.
* taking the address of a UFCS call to a function that meets the previous criteria creates a delegate.
* the `funcptr` member of all delegate types add an additional parameter of type `void*` as the first parameter.
* function pointers with a reference type as their first parameter be implicitly convertible to a function pointer with the same arguments but substituting the first parameter for `void*`.

### Links

[General forum discussion](http://forum.dlang.org/post/qtaiotodqqxqoqmozgrq@forum.dlang.org)

## Terminology

A "reference type" in this proposal is any parameter that is a class, a pointer or has the `ref` modifier. Note that every reference type is stored as a single pointer at runtime which is required to make it compatible with the delegate ABI.

A "free function" is a function that is neither a member function nor a nested function.  Static functions defined inside classes/structs and functions are still "free functions".

A free function with a reference type as its first parameter is said to meet the "delegate criteria".

A "free delegate function" is a free function that meets the delegate criteria.

## Description

It is proposed that functions meeting the "delegate criteria" adopt same ABI as delegates where the first parameter is passed as the "context pointer".  This "delegate criteria" requires that the first parameter be a pointer/reference type. i.e.


```D
// the following free delegate functions all use the same abi which is the
// same abi as the function pointer for void delegate(int,float)
void freeDelegateFunc(void*      , int, float);
void freeDelegateFunc(int*       , int, float);
void freeDelegateFunc(const(int)*, int, float);
void freeDelegateFunc(int[]*     , int, float);
void freeDelegateFunc(ref int[]  , int, float);
void freeDelegateFunc(Class      , int, float);
void freeDelegateFunc(ref Struct , int, float);
void freeDelegateFunc(Struct*    , int, float);
```

These functions are called "free delegate functions" since they are "free functions" that meet the "delegate criteria".  Note that a free delegate function with a class or struct reference as its first parameter will have the same ABI as a member function of that type, i.e.

```D
class Class
{
    void classMemberFunc(int, float);
}
// same ABI as classMemberFunc
void freeDelegateFunc(Class, int, float);

struct Struct
{
    void structMemberFunc(int, float);
}
// same ABI as structMemberFunc
void freeDelegateFunc(ref Struct, int, float);
// same ABI as structMemberFunc
void freeDelegateFunc(Struct*, int, float);
```

### UFCS delegate retrieval

Along with the ABI changes, it is also proposed that taking the address of a UFCS call with any free delegate function creates a delegate just like it would with a member function.

```D
void bar(Class);
Class c;
void delegate() dg = &c.bar;
assert(dg.ptr == c);
assert(dg.funcptr == &bar);
```

By using UFCS to retrieve a delegate, the same syntax is used for member functions and free delegate functions, namely, `&<object>.<function>`. This allows templates and mixins to work with both kinds. It also maintains type safety between the context pointer and the first parameter of the function by "piggy-backing" off the type checking done by the UFCS call.

### Modify the `.funcptr` field on delegates so it correctly reflects the ABI

Note that this ABI change also applies to function pointers.  Because of this, it's necessary to revise the `funcptr` field for delegates.  Consider,

```D
void freeDelegateFunc(Class1, Class2) { }
void delegate(Class2) dg = &new Class1().freeDelegateFunc;

void function(Class2)       func = dg.funcptr; // today
void function(void*,Class2) func = dg.funcptr; // proposed
```

With the new free delegate criteria applied to the current definition of `funcptr`, the function is incorrectly interpreted as an free delegate function with `Class2` as the context pointer; rather, `Class1` is the context pointer with `Class1` being the first parameter.

With the revised definition of `funcptr`, it correctly indicates with `void*` that the context pointer is a dynamic type that can change at runtime.  This also causes the function pointer type to meet the free delegate criteria so its type now represents the correct ABI.

To minimize code breakage from changing `funcptr`, and prevent the need for casting, it is also proposed that all function pointer types be that meet the free delegate criteria be implicitly convertible to the corresponding `funcptr` type, which means substituting the first parameter for `void*`, i.e.

```D
void function(Class)      func1;
void function(ref Struct) func2;
void function(Struct*)    func3;
void function(ref int[])  func4;

void function(void*) voidFunc = func1; // ok
void function(void*) voidFunc = func2; // ok
void function(void*) voidFunc = func3; // ok
void function(void*) voidFunc = func4; // ok
```

Here's an example showing how it can be used with delegates:
```D
void func1(Class);
void func2(ref Struct);

void delegate() dg;
dg.ptr = new Class();
dg.funcptr = &func1;

Struct s;
dg.ptr = &s;
dg.funcptr = &func2;
```

### Mangling

For functions with a class or struct pointer/reference as their first parameter, they should use the same mangline rules as member functions.  For the other free delegate functions, I'm not sure how their mangling should work yet.

## Rationale

This proposal allows free delegate functions to be called as delegates with zero overhead.

```D
void foo(Class c, int, float);
auto c = new Class;
void delegate(int,float) dg = &c.foo;
```
> Note: this use case is different from the `std.functional.toDelegate` method, which will generate a runtime function to translate a delegate call to a function call and doesn't make use of the context pointer.

It also fixes the type of the `.funcptr` field of delegates so that its type correctly represents its ABI, i.e.

```D
void delegate() dg;

void function()      fp = dg.funcptr; // today
void function(void*) fp = dg.funcptr; // with this proposal
```

free delegate functions allow developers to write functions that can be called via delegates even when they cannot be added as member functions (i.e. because the class/struct may be defined in another library like druntime or phobos).

#### Use Cases

There are 2 types of use cases I've identified:

* **Type 1**: Need a delegate where the context pointer is an external type that such that member functions can't be added.
* **Type 2**: Want to call an external function through a delegate.  I should look for functions in druntime/phobos that take template parameters as their first argument that I want to call as delegates.

##### Type 2 Candidates
```D
// object.d, destroy
Struct s;
void delegate() destroyDg = &s.destroy;
Object o;
void delegate(Object o) opEqualsDg = &o.opEquals;
```
```D
// std.range
MyRange range;
void delegate() reverseDg = &range.retro;
void delegate() radialDg = &range.radial;
void delegate() takeOneDg = &range.takeOne;
void delegate() takeNone = &range.takeNone;
void delegate(size_t) takeExactlyDg = &range.takeExactly;
void delegate(size_t) takeDg = &range.take;
void delegate(size_t) strideDg = &range.stride;
void delegate(size_t) tailDg = &range.tail;
void delegate(size_t) dropDg = &range.drop;
// TODO: how would these delegates be retrieved today?
```

```D
T[] rawReadAndCapitalize(T)(ref File file, T[] buffer)
{
    auto result = file.rawRead(buffer);
    foreach (i; 0 .. result.length)
    {
        result[i] = result[i].toUpper;
    }
}

void dump(T)(T[] delegate(T[] buffer) reader)
{
    T[1024] buffer;
    for (;;)
    {
        auto data = reader(buffer);
        if (data.length == 0)
            break;
        write(data);
    }
}

void main()
{
    File file = File("file.txt", "r");
    dump(&file.rawReadAndCapitalize);
}
```


#### Alternative Solutions

Say we want to create a delegate function that takes a `std.stdio.File` reference as the context pointer. Let's call it `writelnWithTime` and have it write a line to the file prefixed with the current time. Normally, functions intended to be used as delegates are added to a type as member functions, but member functions cannot be added to `std.stdio.File` because it is defined in the standard library. One solution is to create a wrapper type and define our new delegate function inside the wrapper, e.g.

```D
struct FileWrapper
{
    File* file;
    void writelnWithTime(string msg)
    {
        file.writeln(Clock.currTime, " ", msg);
    }
}

File file;
auto wrapper = FileWrapper(&file);
auto ourDelegate = &wrapper.writelnWithTime;
```

This works, but comes at a cost. It adds complexity in ownership semantics, potential for scoping errors, unnecessary runtime overhead, an extra level of indirection, and requires extra boilerplate code at the call site to instantiate the wrapper type. The worst problem with this solution is it requires a proliferation of wrapper types. If we define this wrapper in a library that is used by an application, and that application needs to add its own delegate functions, then it must create a "wrapper-wrapper" type, introducing another level of indirection. This adds no value to the program, but does introduce overhead and complexity.

Another solution is to throw type safety out the window, e.g.

```D
struct DummyType
{
    void writelnWithTime(string msg)
    {
        File* file = cast(File*)&this;
        file.writeln(Clock.currTime, " ", msg);
    }
}

File file;
DummyType dummy;
auto ourDelegate = &dummy.writelnWithTime;
ourDelegate.ptr = cast(void*)&file;
```

This also has a cost. Following are the problems seen at both the definition site and the call site.

#### At the function definition site:

* requires the function to be defined inside a dummy wrapper type
* requires a cast from the dummy type context pointer to the actual type you want; this throws away any type safety of the context pointer type and incurs some runtime overhead

#### At the function call site:

* requires an instance of the dummy type to be declared; note that this declaration has no purpose other than to get a delegate to the function
* once the delegate is retrieved, the `ptr` is set as an independent statement which creates a new place for a runtime error
* to set the delegate context pointer, the type must be cast to a `void*`; like the definition site, this throws away any type safety for the context pointer type and incurs some runtime overhead

Some of the issues at the call site can be mitigated with a helper library, i.e.
```D
// assume this is in the standard library
auto makeUntypedDelegate(T, string Member, U)(U u)
{
    T t;
    auto dg = &__traits(getMember, t, Member);
    dg.ptr = u;
    return dg;
}

struct DummyType
{
    void writelnWithTime(string msg)
    {
        File* file = cast(File*)&this;
        file.writeln(Clock.currTime, " ", msg);
    }
}

File file;
auto ourDelegate = makeUntypedDelegate!(DummyType, "writelnWithTime")(&file);
```
However, even with a helper library the context pointer still can't be type checked and every function you'd like to be able to call through a delegate would need to be defined inside a dummy type.

With free delegate functions the solution is simple, clear, and type-safe. You don't need to move your functions inside dummy wrapper types, no casting at the definition site or the call site, no runtime overhead, and delegate retrieval happens in one type-safe statement.

```D
void writelnWithTime(ref File file, string msg)
{
    file.writeln(Clock.currTime, " ", msg);
}

File file;
auto ourDelegate = &file.writelnWithTime;
```

### Breaking changes / deprecation process

* Breaks binary compatibility with functions that meet the external and untyped member criterias.  This means libraries will have to be recompiled.
* Breaks code that depends on `funcptr` having a function pointer type without a context pointer. However, there should be a small amount of code (if any) that would depend on this.
* Taking the address of a UFCS call that omits its parenthesis (i.e. `obj.func` rather than `obj.func(...)`) will now have a different meaning if that function returns a reference type. See "The & operator ambiguity" section.

### Examples

Example to demonstrate the usage:
```D
struct Foo
{
    void bar(int)
    {
    }
}
void baz(ref Foo foo, int)
{
}

// Note that even though `bar` is defined as a member function inside
// the struct Foo, the `baz` function has an identical ABI with `bar`.

void delegate(int) dg;
Foo foo;

dg = &foo.bar;  // a normal member function delegate
dg(42);         // calls foo.bar(42)

dg = &foo.baz;  // using UFCS to retrieve a delegate to the free delegate "baz"
dg(42);         // calls baz(foo, 42);

dg = &baz;      // Error: cannot implicitly convert expression (baz) of type void function(ref Foo, int) to void delegate(int)
```

A more realistic example:
```D
import std.stdio, std.datetime;

void writelnWithTime(T)(ref File foo, T[] buffer)
{
    foo.writeln(Clock.currTime, " ", buffer);
}

void main()
{
    dumpInfo(&stdout.writeln!(const(char)[]));

    // Using UFCS to get a delegate to the free delegate writelnWithTime
    dumpInfo(&stdout.writelnWithTime!(const(char)[]))
}

void dumpInfo(void delegate(const(char)[]) writer)
{
    writer("Some Info:");
    writer("  2 = 2");
    writer("  3 != 4");
}
```

It is worth noting that free delegate functions can be imitated with existing semantics at the cost of type-safety and odd looking code with unclear intentions. The previous example could be "emulated" today like this:
```D
import std.stdio, std.datetime;

// Since there's currently no way to define a function that is ABI-compatible
// with a delegate, we must define our function as a method on a "dummy" type.
// The odd part is that we will be casting the "this" argument to the real
// type we are going to operate on, which in this case is a File*.
struct DummyType
{
    void writelnWithTime(T)(T[] buffer)
    {
        File* file = cast(File*)&this;
        file.writeln(Clock.currTime, " ", buffer);
    }
}

void main()
{
    dumpInfo(&stdout.writeln!(const(char)[]));

    // The DummyType "dummy" variable has no fields and takes no memory.
    // It's only purpose is to create a delegate to the method we want to call.
    DummyType dummy;
    auto writer = &dummy.writelnWithTime!(const(char));

    // Here's where we override the dummy ptr with the real object
    // we want to call the delegate with.
    writer.ptr = &stdout;

    dumpInfo(writer);
}

void dumpInfo(void delegate(const(char)[]) writer)
{
    writer("Some Info:");
    writer("  2 = 2");
    writer("  3 != 4");
}
```

### More Use Cases

Delegates only have one context pointer, which means functions that already use the context pointer like member functions or nested functions cannot add a second context pointer to become free delegate functions of their first parameter type. A function that is already a member/nested function is not considered a "free function" so it doesn't meet the criteria of an free delegate.  The exception is if the function is static, in which case it does become an free delegate.  For example:
```D
struct Foo
{
    // foo is a member function of Foo, so it is not a free function and cannot be an
    // free delegate of Bar
    void foo(Bar bar)
    {
    }
    // foo2 is static so it IS NOT a member function of Foo so it becomes an external
    // member function of Bar
    static void foo2(Bar bar)
    {
        // foo3 is a nested function so it cannot be an free delegate of Bar
        void foo3(Bar bar)
        {
        }
        // foo4 is static, so it does not have a context pointer to the parent function so
        // it is an free delegate of Bar
        static void foo4(Bar bar)
        {
        }
    }
}
```

## The & operator ambiguity

Taking the address of a dotted member function (`&<object>.<member-function>`) creates a delegate. The same syntax can be used for a UFCS call with no arguments (`&<first-argument>.<non-member-function>`); however, in this case it is interpreted as taking the address of the return value of a call to the function with no arguments e.g.

```D
struct Foo
{
    ref int bar1() { /* ... */ }
}
ref int bar2(ref Foo foo) { /* ... */ }

Foo foo;
auto a = &foo.bar1; // creates a delegate, type of a is ref int delegate()
auto b = &foo.bar2; // calls function bar2 and takes the address of the return
                    // value, type of b is int*
```

Note that even though the member function call could be interpreted in the same manner as the UFCS call, the '&' operator gives precedence to intepreting it as a delegate. It is recommended that free delegate functions behave the same way as member functions in this case for two reasons. The first is that it maintains consistent syntax between regular and free delegate functions making it easier for templates/mixins to work with both kinds. The second reason is that with this precedence, there currently exists syntax that expresses the intent to call the function and take the address of the return value, namely, by including an empty parameter list `()` e.g.
```D
ref int bar(ref Foo foo) { /* ... */ }
Foo foo;
auto a = &foo.bar;   // should create a delegate, type of a should be
                     // ref int delegate()
auto b = &foo.bar(); // this is clearly taking the address of the return
                     // value after calling the function, type of b is int*
```
If free delegate functions do not maintain this precedence, there is currently no syntax that expresses the intent to create a delegate rather than take the address of the return value reference.

## Copyright & License

Copyright (c) 2017 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

## Review

[Preliminary Review Round 1](http://forum.dlang.org/post/topmfucguenqpucsbhwi@forum.dlang.org)