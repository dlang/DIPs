# Editions

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1052                                                            |
| Review Count:   | 3                                                               |
| Author:         | √Åtila Neves (atila dot neves at gmail)                          |
| Implementation: |                                                                 |
| Status:         | Accepted                                                        |

## Abstract

An approach to evolving the language to correct past mistakes while allowing for breaking
changes that do not affect code that has already been written.

## Contents
* [Rationale](#rationale)
* [Prior Work](#prior-work)
* [Description](#description)
* [Breaking Changes and Deprecations](#breaking-changes-and-deprecations)
* [Copyright & License](#copyright--license)
* [Reviews](#reviews)

## Rationale

Although D was created with lessons learned from the mistakes of other languages, it of course ended up with mistakes of its own. There are many things about the language that we would like to change, but we are impeded by the likelihood, or sometimes the certainty, that existing code will no longer compile. Worse still is code that compiles under the new language rules but behaves differently.

To overcome limitations imposed by decisions of the past which restrict us to makiing only additive language changes, this document proposes a mechanism to introduce breaking changes that only apply to code which *has not yet been written*. In this way, the language can evolve and become simpler while catering to the existing D codebases at large.

## Prior Work

[Rust editions](https://rust-lang.github.io/rfcs/2052-epochs.html).
[Epochs in C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1881r0.html).

## Description

A D *edition* is a set of changes to the D programming language defined by the D Language Foundation. These changes are allowed to be breaking changes in the sense that they could, when applied, either cause existing, compiling D code to no longer compile, or to change the semantics of existing code should it still compile.

Before an individual language change is included in an edition, it will be implemented and gated behind a `-preview=` flag in the compiler so that it can be tested and tweaked as needed. An edition is then defined as a set of approved preview flags that have been given enough time to mature and prove themselves useful.

This DIP proposes altering the definition of a D module declaration, such that:

1. module declarations can optionally specify a target D edition;
2. module declarations that do not contain a target edition (including module declarations in existing code) are considered to target a default edition;
3. modules without a module declaration are considered to target a default edition.

### Targets

To "target an edition" means a given module is compiled as if the compiler has been invoked with the set of preview flags associated with that edition.

A target edition can be specified by optionally including an edition identifier in the module declaration:

```Grammar
ModuleDeclaration:
    ModuleAttributes(opt) module ModuleFullyQualifiedName Edition(opt);
Edition:
    DecimalInteger
```

A given edition's identifier is assigned upon the edition's release and is always the year of release, e.g.,

```d
module mymod 2025;
```

Every D compiler release predefines a default edition which will become the target edition when no target is explicitly specified in a module declaration. This default is always the latest, officially released edition at the time of the compiler's release.

To aid in transitioning existing code to a new edition, it is possible to override the default edition for a given compiler invocation with a compiler flag such as `-edition=2025`, where `2025` is the edition identifier.

This DIP also recommends a `-E` switch that allows the user to specify a default target edition for all imported modules in a given path. This target overrides the default edition and the `-edition` flag, if present, for modules in the given path. An example:

```
dmd -E2024/path/to/imported/modules
```

If the given path is not already in the set of import paths, it must still be added with `-I`.

```
dmd -E2024/path/to/imported/modules -I/path/to/imported/modules
```

To opt out of editions so that a set of modules is compiled with the pre-editions version of D, the "Zero Edition" identifier of `0` can be specified with both the `-edition` and `-E` flags, e.g., `-edition=0` or `-E0/path/to/imported/modules`.

This DIP proposes that DUB be modified such that DUB recipes (`dub.{sdl,json}`) generated by DUB include an `edition` field allowing a target edition to be specified. DUB recipes that do not include this field will use the Zero Edition target by default to override the predefined compiler default. This way, project dependencies with old code bases will continue to compile with no intervention required by the user.  

### Compatibility

This DIP proposes that editions can only be officially released, i.e., finalized, when both DRuntime and Phobos have been transitioned to that edition.

The feature is meant to be backwards and forwards compatible; it should be possible for a D module targeting one edition to import a D module targeting any other edition. A template must obey the rules of the edition targeted by the module in which it is defined, not the module in which it is instantiated. Compatibility is at the source code level; no promises of ABI compatibility are made. All code, old and new, must be compiled with the same version of the compiler. Only one version of DRuntime, which must support all existing editions, is to be provided with a compiler release.

### A note on safety

It is possible that later editions will fix `@safe`ty issues that cannot be fixed in earlier editions for fear of breaking existing code. In that case, this DIP recommends that functions from previous editions be treated as `@system`. Another way to get around this is to introduce `@trusted` imports.

### What can editions do?

#### Deleting existing features

This would be the easiest change that could be made in a D edition, since it would forbid future D code from using deprecated features. Aside from maintaining the frontend code for those features, there would be no impact.

#### Adding new features

Editions are not necessary for adding new features that are purely additive, i.e., that do not interact with existing features. This document does not propose excluding such features from prior editions and in fact encourages backporting them to previous editions where possible.

#### Changing defaults

Defaults matter because they encourage and influence behaviour. Newer editions could change defaults such as `@system`/`@safe` and others.

#### Changing semantics

An edition could make it so that:

```d
shared int i;
i += 5;
```

would be lowered to:

```d
shared int i;
i.atomicOp!"+="(1);
```

## Examples

The following are examples of what editions could achieve, but this DIP is not arguing for or against any one of them.

### `@safe` by default

There [was a failed attempt](https://github.com/dlang/DIPs/blob/master/DIPs/rejected/DIP1028.md) to make `@safe` the default. It is likely that problems would have been found in its implementation had it succeeded, as all current D code assumes that `@system` is the default outside of attribute inference. Making this change in an edition would side-step that issue.

### `private` by default

The default is currently `public`, which makes it easier to write short scripts and requires less typing. Experience has shown, however, that in larger codebases, it encourages client code to depend on what should have been implementation details and makes refactoring more cumbersome. Defaults matter. Changing the default to `private` would result in less coupled, more maintainable code.

### No exceptions

An edition could replace D's exception system with an alternative approach to error handling, such as one based on sum types.

### No more `lazy`

The `lazy` feature complicates the language and the compiler for little benefit. Users can use an explicit lambda instead.

### No more `alias this`

`alias this` can be used with classes to implement multiple inheritance, exposing them to all of the problems inherent in multiple inheritance. As an added "bonus", multiple inheritance is not defined under the current language rules. A future edition could remove this feature.

### Change class ABI (monitor) and/or hierarchy

An edition could change the ABI of classes in D, possibly removing the monitor. Alternatively, it could introduce a new base class of `Object` as has been proposed before.

## Drawbacks and possible issues

### Compiler complexity

While this feature will simplify D code yet to be written, it will make the compiler more complicated by introducing the requirement to account for each edition of the language. One possible way to bound this complexity could be to only support the last N editions, for N < 5.

### Would editions mean splitting the language into different dialects?

In short, no. It can be argued that this is the current situation with preview switches, in that their existence has already divided the language into 2^N dialects, with N being the number of switches that can be turned on. Editions would actually improve the situation by presenting a monotonic sequence of language features and changes without providing the opportunity to cherry-pick only those a user wants.

### API mismatches

In specific circumstances, it is possible that a change introduced in one edition could introduce an incompatibility with APIs conforming to older editions. For such situations, this DIP oringially proposed the introduction of the special keyword `__EDITION__` which, similarly to `__FILE__` and `__LINE__`, would be evaluated at the "call site", allowing edition-based conditional compilation.

During the final discussion of this DIP in the D Language Foundation's October 2025 monthly meeting, Walter Bright suggested removing this proposed keyword from the DIP. Such a keyword has the potential to introduce "edition hell", reducing source code readability. He recommended we leave it as a possible future addition. Should experience show it to be necessary, it will be easier to add later than it would be to remove should we add it now and later find it to be problematic. Experience may also lead us to an alternative solution, or show that it's not necessary at all.

## Breaking Changes and Deprecations

The editions feature is explicitly designed with the goal of opting out of any breaking changes or deprecations. Existing D code compiled with the Zero Edition target will compile and behave as before.

Targeting a specific edition, however, can cause existing code to no longer compile, and that is a choice to be made by the programmer. It is hoped that tooling can be written to aid in this process.

## Copyright & License

Copyright (c) 2025 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

## Reviews

This DIP [was discussed for several months](https://forum.dlang.org/post/tskwospngntbnqiuxbag@forum.dlang.org) in the DIP Ideas forum.

This DIP underwent [one round of discussion in the DIP Development forum](https://forum.dlang.org/post/epzrvlljudykzhgwrpku@forum.dlang.org).

Because this DIP was authored by one of the language maintainers, it was a topic in multiple D Language Foundation monthly meetings and one focused meeting. During a final dicussion in the October 2025 monthly meeting, those present agreed the DIP should move forward to Formal Assessment with three changes:

1. clarify that the `-E` switch does not modify the import path;
2. specify that an edition's identifier is always the year in which it is released;
3. remove the `__EDITION__` special keyword and add a comment explaining why.

The DIP was subsequently approved by the language maintainers.
